class Postgres
{
  /* private */ func validate(info, result)
  {
    var CONNECTION_OK = 0;
    var PGRES_COMMAND_OK = 1;
    var PGRES_TUPLES_OK = 2;
    var failed = false;
    # var message;

    if (result)
    {
      var status = PQresultStatus(result);
      failed = !(status == PGRES_COMMAND_OK || status == PGRES_TUPLES_OK);
    }
    else
    {
      failed = (PQstatus(@connection) != CONNECTION_OK);
    }

    if (!failed)
    {
      return nil;
    }

    print(info);
    print(" failed: [");
    var msg_ptr = PQerrorMessage(@connection);
    var<String> msg = msg_ptr;
    print(msg);
    puts("].");
    if (result)
    {
      PQclear(result);
    }
    PQfinish(@connection);
    exit(1);
  }

  // "postgresql://dablang_ex0004@localhost/dablang_ex0004"
  func __construct(connection_query) {
     @connection = PQconnectdb(connection_query);
    self.validate("Connection to database", nil);
  }

  func raw_execute(sql<String>, binary<Boolean> = true) {

    print(" > ");
    puts(sql);
    
    //func PQexecParams<IntPtr>(conn<IntPtr>, command<String>, nParams<Int32>, paramTypes<IntPtr>,
    //                        paramValues<IntPtr>, paramLengths<IntPtr>, paramFormats<IntPtr>, resultFormat<Int32>) {}
    var resultFormat = 0;
    if (binary) { resultFormat = 1; }
    
    var res = PQexecParams(@connection, sql, 0, nil, nil, nil, nil, resultFormat);
    
    print(" >> result: ");

    print(PQresultStatus(res));
    puts(".");
    self.validate("SQL query", res);
    return res;        
  }

  func execute(sql<String>) {
    return PgResultset.new(self.raw_execute(sql));
  }
  
}

class PgResultset {
  func __construct(query) {
    
    @query = query;    
    @ncolumns = PQnfields(@query);

    @columns = @[];    
    @ncolumns.times() ^ (i) {
      var ptr = PQfname(@query, i);
      var<String> column_name = ptr;
      @columns.insert(column_name);
    };
    
  }

  func columns() {
    return @columns;
  }
}

func level0() {
  
}
